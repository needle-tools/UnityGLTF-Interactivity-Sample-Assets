using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityGLTF.Interactivity;
using UnityGLTF.Interactivity.Export;
using UnityGLTF.Interactivity.Schema;

public class MathTests : MonoBehaviour, IInteractivityExport
{
    public string schema = "math/add";
    public object a, b, c;
    public object expected;
    public Transform pass;
    public TMPro.TMP_Text label;
    
    private static Dictionary<string, Type> schemasByTypeName = null;
    
    static void Setup()
    {
        var schemas = TypeCache.GetTypesDerivedFrom<GltfInteractivityNodeSchema>();
        schemasByTypeName = new Dictionary<string, Type>();
        foreach (var schema in schemas)
        {
            var instance = (GltfInteractivityNodeSchema) System.Activator.CreateInstance(schema);
            schemasByTypeName.Add(instance.Type, schema);
        }
    }
    
    static GltfInteractivityNodeSchema GetSchema(string name)
    {
        if (schemasByTypeName == null)
            Setup();
        
        if (schemasByTypeName == null)
            throw new Exception("No schemas found");
        
        if (schemasByTypeName.TryGetValue(name, out var schemaType))
        {
            var schema = (GltfInteractivityNodeSchema) System.Activator.CreateInstance(schemaType);
            return schema;
        }
        
        var autoGeneratedSchema = GenericUnitExport.GetAutoGeneratedSchema(name);
        if (autoGeneratedSchema != null)
        {
            return autoGeneratedSchema;
        }
        
        throw new Exception($"Schema not found: {name}");
    }

    public void OnInteractivityExport(GltfInteractivityExportContext context, GltfInteractivityExportNodes nodes)
    {
        if (!isActiveAndEnabled) return;
        
        var testNode = nodes.CreateNode(GetSchema(schema));
        if (testNode.ValueSocketConnectionData.ContainsKey("a")) testNode.SetValueInSocket("a", a, TypeRestriction.LimitToFloat);
        if (testNode.ValueSocketConnectionData.ContainsKey("b")) testNode.SetValueInSocket("b", b, TypeRestriction.LimitToFloat);
        if (testNode.ValueSocketConnectionData.ContainsKey("c")) testNode.SetValueInSocket("c", c, TypeRestriction.LimitToFloat);
        testNode.OutValueSocket["value"].expectedType = ExpectedType.Float;

        var equalsNode = default(GltfInteractivityNode);
        
        var expectedRestriction = expected is float ? TypeRestriction.LimitToFloat : TypeRestriction.LimitToBool;
        var isSpecialValue = expected.Equals(float.NaN) || expected.Equals(float.PositiveInfinity) || expected.Equals(float.NegativeInfinity);
        var testApproximateEquality = schema == "math/e" || schema == "math/pi" || expected is float && !isSpecialValue;
        if (testApproximateEquality)
        {
            // Approximate equality: abs(A - B) < epsilon
            var subtractNode = nodes.CreateNode(GetSchema("math/sub"));
            subtractNode.SetValueInSocketSource("a", testNode, "value");
            subtractNode.SetValueInSocket("b", expected, expectedRestriction);
            var absNode = nodes.CreateNode(GetSchema("math/abs"));
            absNode.SetValueInSocketSource("a", subtractNode, "value");
            var lessThanNode = nodes.CreateNode(GetSchema("math/lt"));
            lessThanNode.SetValueInSocketSource("a", absNode, "value");
            lessThanNode.SetValueInSocket("b", 0.0001f);
            equalsNode = lessThanNode;   
        }
        else
        {
            equalsNode = nodes.CreateNode(GetSchema("math/eq"));
            equalsNode.SetValueInSocket("a", expected, expectedRestriction);
            equalsNode.SetValueInSocketSource("b", testNode, "value");

            // Special case: comparison between NaN and NaN is always false â€“ to get a green checkbox, we need to invert the result.
            // Testing with math/isnan is a separate test case!
            if (expected.Equals(float.NaN))
            {
                var notNode = nodes.CreateNode(GetSchema("math/not"));
                notNode.SetValueInSocketSource("a", equalsNode, "value", TypeRestriction.LimitToBool);
                equalsNode = notNode;
            }
        }
        
        // for logging: switch based on the equals node
        var switchNode = nodes.CreateNode(GetSchema("flow/branch"));
        switchNode.SetValueInSocketSource("condition", equalsNode, "value", TypeRestriction.LimitToBool);
        var loggingNode1 = nodes.CreateNode(new ADBE_OutputConsoleNode());
        loggingNode1.SetValueInSocket("message", "Failed: " + schema + ". Expected: " + expected + ". Actual: ");
        var loggingNode2 = nodes.CreateNode(new ADBE_OutputConsoleNode());
        loggingNode2.SetValueInSocketSource("message", testNode, "value");
        switchNode.SetFlowOut("false", loggingNode1, "in");
        loggingNode1.SetFlowOut("out", loggingNode2, "in");

        var combine3Node = nodes.CreateNode(GetSchema("math/combine3"));
        combine3Node.SetValueInSocket("a", 0f);
        combine3Node.SetValueInSocket("b", 0f);
        combine3Node.SetValueInSocketSource("c", equalsNode, "value", TypeRestriction.LimitToFloat);
        
        var setPositionNode = nodes.CreateNode(GetSchema("pointer/set"));
        GltfInteractivityNodeHelper.AddPointerConfig(setPositionNode, "/nodes/{nodeIndex}/translation");
        int thisTransformIndex = context.exporter.GetTransformIndex(pass);
        GltfInteractivityNodeHelper.AddPointerTemplateValueInput(setPositionNode, "nodeIndex", thisTransformIndex);
        
        setPositionNode.SetValueInSocketSource("value", combine3Node, "value", TypeRestriction.LimitToFloat3);
        
        var startNode = nodes.CreateNode(GetSchema("event/onStart"));
        var sequenceNode = nodes.CreateNode(GetSchema("flow/sequence"));
        sequenceNode.FlowSocketConnectionData.Add("0", new GltfInteractivityNode.FlowSocketData { Id = "0" });
        sequenceNode.FlowSocketConnectionData.Add("1", new GltfInteractivityNode.FlowSocketData { Id = "1" });
        startNode.SetFlowOut("out", sequenceNode, "in");
        sequenceNode.SetFlowOut("0", setPositionNode, "in");
        sequenceNode.SetFlowOut("1", switchNode, "in");
        
        label.text = schema;
    }
}
